# Generated by claude-3-7-sonnet-latest

import uuid
from typing import List, Dict, Any
import questionary

from langgraph.graph import START, END, StateGraph
from langgraph.checkpoint.sqlite import SqliteSaver
from langgraph.constants import Send
from langchain_core.runnables.config import RunnableConfig

# Import the state and node functions
from state_code import State
from node_code import orchestrator, worker, synthesizer

# Import worker LLMs config
from lgcodegen_llm import get_worker_llms_config

# Routing Functions
def assign_workers(state: State):
    """Assign workers to each section in the state, using multiple LLMs per section"""
    # Get worker LLMs configuration
    worker_llms = get_worker_llms_config()
    if not worker_llms:
        # Fallback to single worker per section if no worker LLMs are configured
        return [Send("worker", {"section": s}) for s in state.sections]
    
    # For each section, generate multiple workers using different LLMs
    worker_assignments = []
    for section in state.sections:
        for idx, _ in enumerate(worker_llms):
            # Add metadata to specify which worker LLM to use
            worker_assignments.append(
                Send("worker", {"section": section}, {"metadata": {"worker_index": idx}})
            )
    
    # Kick off all worker instances in parallel via Send() API
    return worker_assignments

def make_builder():
    """Create and return the StateGraph builder for the report generation workflow"""
    builder = StateGraph(State)
    
    # Add node functions
    builder.add_node("orchestrator", orchestrator)
    builder.add_node("worker", worker)
    builder.add_node("synthesizer", synthesizer)
    
    # Add edges for execution flow
    builder.add_edge(START, "orchestrator")
    
    # Handle the worker node processing of sections
    builder.add_conditional_edges(
        "orchestrator", assign_workers, ["worker"]
    )
    
    builder.add_edge("worker", "synthesizer")
    builder.add_edge("synthesizer", END)
    
    return builder

if __name__ == "__main__":
    # Get report topic from user
    report_topic = questionary.text("Please enter a report topic:").ask()
    
    # Create initial state with the topic
    initial_state = State(topic=report_topic)
    
    # Create the graph
    with SqliteSaver.from_conn_string("report_generator.db") as checkpointer:
        builder = make_builder()
        report_graph = builder.compile(checkpointer=checkpointer)
        workflow = report_graph
        
        # Generate a unique thread ID for this run
        thread_id = str(uuid.uuid4())
        config = RunnableConfig(configurable={"thread_id": thread_id})
        
        # Stream and display the outputs
        print(f"\nGenerating report on: {report_topic}\n")
        print("=" * 50)
        
        for output in workflow.stream(initial_state, config=config):
            print(f"\n{output}\n")
            
        print("=" * 50)
        print("\nFinal report state:")
        state = workflow.get_state(config)
        
        # Display relevant parts of the final state
        if hasattr(state, "values"):
            for k, v in state.values.items():
                if k != "processed_sections":  # The full sections might be too verbose
                    print(f"  {k}: {v}")
            
            # Show how many sections were processed
            if "processed_sections" in state.values:
                print(f"  Processed {len(state.values['processed_sections'])} sections")
        else:
            print(state)