
# Graph State: AgentState
from typing import Annotated, TypedDict

def add_str_to_list(a=None, b=""):
    return (a if a is not None else []) + ([b] if not isinstance(b, list) else b)

def add_int(a, b):
    if b == 0: return 0
    return b+1 if a==b else b

class AgentState(TypedDict):
    nodes_visited: Annotated[list[str], add_str_to_list]
    counter: Annotated[int, add_int]

def initialize_state():
    return { 'nodes_visited': [], 'counter': 0 }


# Node Functions
def code_node(state: AgentState, *, config:Optional[RunnableConfig] = None):
    print(f'NODE: code_node')
    return { 'nodes_visited': 'code_node', 'counter': state['counter'] + 1 }

def research_node(state: AgentState, *, config:Optional[RunnableConfig] = None):
    print(f'NODE: research_node')
    return { 'nodes_visited': 'research_node', 'counter': state['counter'] + 1 }

def supervisor_agent(state: AgentState, *, config:Optional[RunnableConfig] = None):
    print(f'NODE: supervisor_agent')
    return { 'nodes_visited': 'supervisor_agent', 'counter': state['counter'] + 1 }


import random

def random_one_or_zero():
    return random.choice([False, True])

# Conditional Edge Functions
# Functions that determine which path to take in the graph
def next_is_researcher(state: AgentState) -> bool:
    result = random_one_or_zero()
    print(f'CONDITION: next_is_researcher. Result: {result}')
    return result


def next_is_coder(state: AgentState) -> bool:
    result = random_one_or_zero()
    print(f'CONDITION: next_is_coder. Result: {result}')
    return result


def next_is_finish(state: AgentState) -> bool:
    result = random_one_or_zero()
    print(f'CONDITION: next_is_finish. Result: {result}')
    return result


# Graph Builder: supervisor
from langgraph.graph import START, END, StateGraph
from langgraph.checkpoint.memory import MemorySaver
import sqlite3

checkpoint_saver = MemorySaver()
builder_supervisor = StateGraph(AgentState)
builder_supervisor.add_node('supervisor_agent', supervisor_agent)
builder_supervisor.add_node('research_node', research_node)
builder_supervisor.add_node('code_node', code_node)
builder_supervisor.add_edge(START, 'supervisor_agent')
def after_supervisor_agent(state: AgentState):
    if next_is_researcher(state):
        return 'research_node'
    elif next_is_coder(state):
        return 'code_node'
    elif next_is_finish(state):
        return 'END'
    return 'END'

supervisor_agent_conditional_edges = { 'research_node': 'research_node', 'code_node': 'code_node', 'END': END }
builder_supervisor.add_conditional_edges('supervisor_agent', after_supervisor_agent, supervisor_agent_conditional_edges)

builder_supervisor.add_edge('research_node', 'supervisor_agent')
builder_supervisor.add_edge('code_node', 'supervisor_agent')

supervisor = builder_supervisor.compile(checkpointer=checkpoint_saver)

