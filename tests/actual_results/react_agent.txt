
# Graph State: State
from typing import Annotated, TypedDict

def add_str_to_list(a=None, b=""):
    return (a if a is not None else []) + ([b] if not isinstance(b, list) else b)

def add_int(a, b):
    if b == 0: return 0
    return b+1 if a==b else b

class State(TypedDict):
    nodes_visited: Annotated[list[str], add_str_to_list]
    counter: Annotated[int, add_int]

def initialize_State():
    return { 'nodes_visited': [], 'counter': 0 }


# Node Functions
def call_model(state: State, *, config:Optional[RunnableConfig] = None):
    print(f'NODE: call_model')
    return { 'nodes_visited': 'call_model', 'counter': state['counter'] + 1 }

def tool_node(state: State, *, config:Optional[RunnableConfig] = None):
    print(f'NODE: tool_node')
    return { 'nodes_visited': 'tool_node', 'counter': state['counter'] + 1 }


import random

def random_one_or_zero():
    return random.choice([False, True])

# Conditional Edge Functions
# Functions that determine which path to take in the graph
def should_call_tool(state: State) -> bool:
    result = random_one_or_zero()
    print(f'CONDITION: should_call_tool. Result: {result}')
    return result


# Graph Builder: react_agent
from langgraph.graph import START, END, StateGraph
from langgraph.checkpoint.memory import MemorySaver
import sqlite3

checkpoint_saver = MemorySaver()
builder_react_agent = StateGraph(State)
builder_react_agent.add_node('call_model', call_model)
builder_react_agent.add_node('tool_node', tool_node)
builder_react_agent.add_edge(START, 'call_model')
def after_call_model(state: State):
    if should_call_tool(state):
        return 'tool_node'
    return 'END'

call_model_conditional_edges = { 'tool_node': 'tool_node', 'END': END }
builder_react_agent.add_conditional_edges('call_model', after_call_model, call_model_conditional_edges)

builder_react_agent.add_edge('tool_node', 'call_model')

react_agent = builder_react_agent.compile(checkpointer=checkpoint_saver)

